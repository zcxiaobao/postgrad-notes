(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{386:function(v,_,t){"use strict";t.r(_);var a=t(51),e=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"文章信息"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#文章信息"}},[v._v("#")]),v._v(" 文章信息")]),v._v(" "),t("ul",[t("li",[v._v("题目: 基于改进kNN算法的非侵入式负荷识别方法")]),v._v(" "),t("li",[v._v("作者: 延菲,张瑞祥,孙耀杰,陶余会,黄国平,孙伟涛")]),v._v(" "),t("li",[v._v("期刊: 复旦学报(自然科学版). 2021,60(02)")]),v._v(" "),t("li",[v._v("关键词: 负荷识别;kNN算法;二值V-I轨迹;综合相似度;")]),v._v(" "),t("li",[v._v("英文关键词: load identification; KNN algovithm; binary V-I trajectory; comprehensive similarity")])]),v._v(" "),t("h2",{attrs:{id:"文章总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#文章总结"}},[v._v("#")]),v._v(" 文章总结")]),v._v(" "),t("p",[v._v("KNN当数据集存在不平衡问题时，样本数量较多的类别会对样本数量较少的类别造成干扰，文章针对这一问题，通过为训练样本分配不同的权重，增加少数类样本在分类判决时的表决权。")]),v._v(" "),t("p",[v._v("文章选取的负荷特征为 "),t("code",[v._v("V-I")]),v._v(" 轨迹和幅值，并提出了基于两种特征综合相似度的负荷类别判决方法。")]),v._v(" "),t("p",[v._v("对于 "),t("code",[v._v("V-I")]),v._v(" 曲线，通过映射做归一化处理，将原始 "),t("code",[v._v("V-I")]),v._v(" 数据转化为二值 "),t("code",[v._v("V-I")]),v._v(" 轨迹。")]),v._v(" "),t("p",[v._v("评价指标采用宏平均值 "),t("code",[v._v("F1")]),v._v(" 、精确率、召回率等，类似"),t("a",{attrs:{href:""}}),v._v("，使用了同样的判别方法")]),v._v(" "),t("p",[v._v("最终通过 "),t("code",[v._v("PLAID")]),v._v(" 数据集和采集的实验室数据验证改进的 "),t("code",[v._v("KNN")]),v._v(" 算法的有效性。")]),v._v(" "),t("h2",{attrs:{id:"学习记录"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#学习记录"}},[v._v("#")]),v._v(" 学习记录")]),v._v(" "),t("h3",{attrs:{id:"knn算法的缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#knn算法的缺点"}},[v._v("#")]),v._v(" KNN算法的缺点")]),v._v(" "),t("p",[v._v("kNN算法的缺点在于当数据集存在不平衡问题时，样本数量较多的多数类训练样本容易被选为K最近邻，对少数类的判决造成干扰．")]),v._v(" "),t("h3",{attrs:{id:"knn缺点解决方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#knn缺点解决方案"}},[v._v("#")]),v._v(" KNN缺点解决方案")]),v._v(" "),t("ol",[t("li",[v._v("欠采样和过采样: 删除多数类样本和合成少数类样本，从而消除数据集不平衡问题(类似英文文献中提到的合成数据)")])]),v._v(" "),t("blockquote",[t("p",[v._v("如何合成数据，根据什么样的规则合成数据？(有待查询)")])]),v._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[v._v("对算法进行改进，为训练样本分配不同的权重，增加少数类样本在分类判决时的表决权．")])]),v._v(" "),t("p",[v._v("此文章中使用的方法为第二种方法，权重分配方法也比较简单，使用 "),t("code",[v._v("weight(i) = 1 / size(i)")]),v._v(" ，遵循少数类样本权重大、多数类样本权重小原则。")]),v._v(" "),t("h3",{attrs:{id:"关于对-knn-分配权重的疑问与展望"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#关于对-knn-分配权重的疑问与展望"}},[v._v("#")]),v._v(" 关于对 KNN 分配权重的疑问与展望")]),v._v(" "),t("p",[t("strong",[v._v("仅通过样本数量来赋权值真的好吗？如果换做更专业的分配权重方法是否会提高算法的精准度?")])]),v._v(" "),t("p",[v._v("我查阅了几篇文章，目前在别的研究方向 "),t("code",[v._v("KNN")]),v._v(" 一般使用 "),t("code",[v._v("DS-WKNN")]),v._v(" 基于距离加权 或者 "),t("code",[v._v("KDF-WKNN")]),v._v(" 基于核的差重建方法分配权重，亦或者给上述方法添加修正因子，进一步提高权重分配合理性。")]),v._v(" "),t("p",[v._v("我主要查了知网论文，目前 "),t("code",[v._v("KNN")]),v._v(" 在 "),t("code",[v._v("NILM")]),v._v(" 的应用不多，改进也只有一篇，再次改进不知道是否可以成为研究方向，先记录一下。")]),v._v(" "),t("h3",{attrs:{id:"综合判别法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#综合判别法"}},[v._v("#")]),v._v(" 综合判别法")]),v._v(" "),t("p",[v._v("综合判别法的思路并不难，大致分为下面四部:")]),v._v(" "),t("ol",[t("li",[t("p",[v._v("计算待测样本与所有训练样本的 "),t("code",[v._v("V-I")]),v._v(" 轨迹相似度和幅值相似度，分别记为 "),t("code",[v._v("Sim1")]),v._v(" 和 "),t("code",[v._v("Sim2")]),v._v(" "),t("br"),t("strong",[v._v("Sim1 = 1 / (1 + dist1)")]),t("br"),v._v(" "),t("strong",[v._v("Sim2 = 1 / (1 + dist2)")]),t("br"),v._v("\ndist1和dist2分别为 "),t("code",[v._v("2")]),v._v(" 个样本间 "),t("code",[v._v("V-I")]),v._v(" 轨迹的距离和幅值的距离，均为欧氏距离．")])]),v._v(" "),t("li",[t("p",[v._v("按照 Sim1 的大小降序排列，取前 "),t("code",[v._v("K")]),v._v(" 个 "),t("code",[v._v("Sim1")]),v._v(" 最大的训练样本作为当前测试样本的K最近邻；")])]),v._v(" "),t("li",[t("p",[v._v("计算当前待测样本与所有 K 最近邻的综合相似度")]),v._v(" "),t("p",[t("strong",[v._v("Sim(a, Tj) = Sim1(a, Tj) * weight(Tj) - Sim2(a, Tj)")])])]),v._v(" "),t("li",[t("p",[v._v("统计待测样本与 "),t("code",[v._v("K")]),v._v(" 个最近邻中各类的总综合相似度，取总综合相似度最大的类作为预测结果。")])])]),v._v(" "),t("h3",{attrs:{id:"评价指标"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#评价指标"}},[v._v("#")]),v._v(" 评价指标")]),v._v(" "),t("p",[v._v("使用宏平均 "),t("code",[v._v("F1")]),v._v(" 值评估算法有效性。")]),v._v(" "),t("blockquote",[t("p",[v._v("宏平均 "),t("code",[v._v("F1")]),v._v(" 值参考链接 : "),t("RouterLink",{attrs:{to:"/knowledge/TPFPFNTNF1.html"}},[v._v("宏平均值、精确率、召回率等")])],1)]),v._v(" "),t("h2",{attrs:{id:"疑问"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#疑问"}},[v._v("#")]),v._v(" 疑问")]),v._v(" "),t("ol",[t("li",[v._v("二值 "),t("code",[v._v("V-I")]),v._v(" 轨迹如何做 "),t("code",[v._v("KNN")]),v._v(" ，如何求其欧氏距离？")]),v._v(" "),t("li",[v._v("二值 "),t("code",[v._v("V-I")]),v._v(" 轨迹是怎样实现归一化的？")])])])}),[],!1,null,null,null);_.default=e.exports}}]);